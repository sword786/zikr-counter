<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Counter App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Tone.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Global box-sizing for better layout control */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Custom styles for Inter font and vibrant gradients */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensures vertical centering for the whole app */
            background: linear-gradient(135deg, #ff6b6b, #4bcffa, #6a5af9, #ffcc5c); /* Vibrant gradient background */
            background-size: 400% 400%;
            animation: gradientAnimation 15s infinite alternate;
            margin: 0;
            padding: 0.5rem; /* Slightly reduced overall body padding to prevent horizontal scroll */
            color: #374151; /* Default text color */
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .main-app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1200px; /* Limit overall width */
            background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white container */
            border-radius: 1.5rem; /* Equivalent to rounded-3xl */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); /* Stronger shadow */
            backdrop-filter: blur(10px); /* Stronger blur */
            overflow: hidden; /* Ensure rounded corners clip content, no overflow on main container */
            min-height: 90vh; /* Allow it to grow, but ensure a good minimum size */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .main-app-container {
                flex-direction: row;
                min-height: 80vh; /* Changed from height to min-height to allow content to expand */
            }
        }

        .sidebar {
            width: 100%;
            background-color: rgba(248, 250, 252, 0.8); /* Light background for sidebar */
            padding: 1.5rem;
            border-bottom: 1px solid rgba(226, 232, 240, 0.5);
            max-height: 50vh; /* Max height for scroll on small screens for the sidebar content itself */
            overflow-y: auto; /* Enable scrolling */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .sidebar {
                min-width: 300px;
                max-width: 300px;
                border-right: 1px solid rgba(226, 232, 240, 0.5);
                border-bottom: none;
                max-height: none; /* No max height on larger screens, sidebar can grow */
            }
        }

        .counter-main-display {
            flex-grow: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow-y: auto; /* Allow scrolling if content overflows vertically within this section */
            /* Removed max-height: 100%; to allow internal content to dictate height and scroll */
        }

        .section-title {
            color: #374151;
            margin-bottom: 1.5rem;
        }

        #counterDisplay {
            font-size: 6rem;
            line-height: 1;
            font-weight: 800;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            background-image: linear-gradient(to right, #3b82f6, #9333ea);
            margin-bottom: 1.5rem;
            transition: transform 0.2s ease-out;
            transform: scale(1);
            letter-spacing: -0.05em;
        }

        @media (min-width: 640px) {
            #counterDisplay {
                font-size: 7rem;
            }
        }

        @media (min-width: 768px) {
            #counterDisplay {
                font-size: 8rem;
            }
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px; /* Limit width of controls */
        }

        @media (min-width: 640px) {
            .controls-container {
                flex-direction: row;
                justify-content: center;
            }
        }

        .counter-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 1.5rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .counter-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        #incrementBtn {
            background-image: linear-gradient(to right, #43cea2, #185a9d);
            color: white;
        }

        #decrementBtn {
            background-image: linear-gradient(to right, #ff9966, #ff5e62);
            color: white;
        }

        #resetBtn {
            background-image: linear-gradient(to right, #84fab0, #8fd3f4);
            color: #333;
        }

        .settings-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            background-color: rgba(255, 255, 255, 0.7);
            width: 100%;
            max-width: 400px;
        }

        @media (min-width: 640px) {
            .settings-container {
                grid-template-columns: auto auto;
                gap: 1rem 2rem;
            }
        }

        .settings-container label {
            font-weight: 600;
            color: #4a5568;
        }

        .settings-container input,
        .settings-container select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        .settings-container input:focus,
        .settings-container select:focus {
            border-color: #6366f1;
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25);
        }

        /* Styles for the counter list in sidebar */
        .counter-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }

        .counter-list-item:hover {
            background-color: #f0f4f8;
            transform: translateX(5px);
        }

        .counter-list-item.active {
            background-color: #e0f2fe; /* Light blue for active item */
            border: 2px solid #3b82f6; /* Blue border for active item */
            font-weight: 700;
        }

        .counter-list-item span {
            flex-grow: 1;
            text-align: left;
            padding-right: 0.5rem;
            color: #1f2937;
        }

        .counter-list-item button {
            background: none;
            border: none;
            color: #ef4444; /* Red for delete icon */
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: color 0.2s;
        }

        .counter-list-item button:hover {
            color: #b91c1c;
            background-color: #fee2e2;
        }

        .add-counter-form {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        .add-counter-form input {
            flex-grow: 1;
            padding: 0.6rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
        }

        .add-counter-form button {
            background-color: #22c55e; /* Green for add button */
            color: white;
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .add-counter-form button:hover {
            background-color: #16a34a;
        }

        /* Message box styling */
        .message-box {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            background-color: #ef4444; /* Red background for error */
            color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .message-box.show {
            opacity: 1;
        }

        /* Toggle switch styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(16px);
            -ms-transform: translateX(16px);
            transform: translateX(16px);
        }

        /* File input styling with Tailwind helpers */
        input[type="file"]::file-selector-button {
            @apply mr-4 py-2 px-4 rounded-full border-0 text-sm font-semibold bg-blue-50 text-blue-700 hover:bg-blue-100;
        }

        /* Progress Bar Styling */
        .progress-bar-container {
            width: 100%;
            height: 1rem;
            background-color: #e2e8f0; /* Light gray background */
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures inner bar is clipped */
            margin-top: 1rem; /* Space above progress bar */
            margin-bottom: 1.5rem; /* Space below progress bar */
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%; /* Initial width */
            background-color: #3b82f6; /* Blue fill color */
            border-radius: 0.5rem;
            transition: width 0.3s ease-in-out; /* Smooth transition for width changes */
        }

        /* Splash Screen Styling */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff6b6b, #4bcffa, #6a5af9, #ffcc5c); /* Match body background */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999; /* Ensure it's on top */
            opacity: 1;
            transition: opacity 1s ease-out;
        }

        #splash-screen.fade-out {
            opacity: 0;
            pointer-events: none; /* Disable interaction during fade-out */
        }

        #splash-screen img {
            width: 300px;
            height: 300px;
            border-radius: 1.5rem; /* Rounded corners for the icon */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        #splash-screen p {
            margin-top: 1rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        /* Page specific styles */
        #countersListPage {
            display: flex; /* Flex layout for the list page */
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Max width for the list on larger screens */
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            min-height: 50vh; /* Ensure it doesn't collapse */
            flex-grow: 1; /* Allow it to take available height */
        }

        #singleCounterPage {
            position: relative; /* For absolute positioning of the back button */
            display: none; /* Hidden by default */
            flex-grow: 1; /* Allow it to take available height */
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow-y: auto; /* This section itself can scroll if content overflows */
            background-color: rgba(255, 255, 255, 0.95); /* Apply background to single counter page */
            border-radius: 1.5rem; /* Match main container radius */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            backdrop-filter: blur(10px);
            min-height: 80vh; /* Ensure it has some height */
        }

        /* Responsive adjustments for page display */
        @media (min-width: 768px) {
            #countersListPage {
                height: auto; /* Let content dictate height, but maintain min-height */
                min-height: 80vh; /* Match main app container min-height on larger screens */
            }
            #singleCounterPage {
                width: 100%; /* Take full width when sidebar is not present */
                height: auto; /* Let content dictate height, but maintain min-height */
                min-height: 80vh; /* Match main app container min-height */
            }
        }

        /* Custom Confirmation Modal */
        #confirmationModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Above splash screen */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        #confirmationModal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 90%;
            width: 400px;
        }

        .modal-content p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: #374151;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .modal-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }

        .modal-button.confirm {
            background-color: #ef4444; /* Red for delete */
            color: white;
        }
        .modal-button.confirm:hover {
            background-color: #dc2626;
            transform: scale(1.02);
        }

        .modal-button.cancel {
            background-color: #e2e8f0; /* Light gray for cancel */
            color: #4a5568;
        }
        .modal-button.cancel:hover {
            background-color: #cbd5e0;
            transform: scale(1.02);
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen">
        <img src="https://placehold.co/300x300/6a5af9/FFFFFF?text=Super+Counter" alt="App Icon">
        <p>Loading Super Counter App...</p>
    </div>

    <!-- Main Application Container (initially hidden) -->
    <div class="main-app-container" style="display: none;">
        <!-- Counters List Page -->
        <div id="countersListPage">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">My Counters</h2>
            <div class="add-counter-form">
                <input type="text" id="newCounterNameInput" placeholder="New counter name (optional)" class="focus:border-blue-500 focus:ring-blue-500">
                <button id="addCounterBtn"><i class="fas fa-plus"></i> Add</button>
            </div>
            <ul id="counterList" class="list-none p-0 m-0 flex-grow overflow-y-auto">
                <!-- Counter items will be populated here by JavaScript -->
            </ul>
        </div>

        <!-- Single Counter Page (Initially hidden, shown when a counter is selected) -->
        <div id="singleCounterPage" style="display: none;">
            <button id="backToCountersBtn" class="absolute top-4 left-4 counter-button bg-blue-500 hover:bg-blue-600 text-white text-sm py-2 px-4 rounded-full">
                <i class="fas fa-arrow-left mr-2"></i> Back to Counters
            </button>

            <h1 id="currentCounterName" class="text-4xl sm:text-5xl md:text-6xl font-extrabold text-gray-800 mb-8 section-title">
                No Counter Selected
            </h1>
            <div id="counterDisplay">0</div>

            <!-- Progress Bar -->
            <div id="progressBarContainer" class="progress-bar-container" style="display: none;">
                <div id="progressBarFill" class="progress-bar-fill"></div>
            </div>

            <div class="controls-container">
                <button id="decrementBtn" class="counter-button"><i class="fas fa-minus text-2xl"></i></button>
                <button id="incrementBtn" class="counter-button"><i class="fas fa-plus text-2xl"></i></button>
            </div>
            <button id="resetBtn" class="counter-button w-full sm:w-auto"><i class="fas fa-undo mr-2"></i> Reset Current</button>

            <div class="settings-container mt-8">
                <div class="col-span-full flex items-center justify-between">
                    <label for="zikrModeToggle" class="text-sm font-medium text-gray-700">Enable Zikr Mode:</label>
                    <label class="switch">
                        <input type="checkbox" id="zikrModeToggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <div id="zikrTargetContainer" class="col-span-full" style="display: none;">
                    <label for="zikrTargetInput" class="block text-sm font-medium text-gray-700">Zikr Target:</label>
                    <input type="number" id="zikrTargetInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" placeholder="e.g., 50, 100" min="0">
                </div>

                <div class="col-span-full flex items-center justify-between">
                    <label for="soundEnabledToggle" class="text-sm font-medium text-gray-700">Enable Sound Alert:</label>
                    <label class="switch">
                        <input type="checkbox" id="soundEnabledToggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- Custom Sound Options -->
                <div class="col-span-full" id="customSoundOptions" style="display: none;">
                    <label for="customSoundFileInput" class="block text-sm font-medium text-gray-700">Upload Custom Sound (.mp3, .wav):</label>
                    <input type="file" id="customSoundFileInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" accept="audio/mpeg, audio/wav">
                    <p id="customSoundFileNameDisplay" class="text-xs text-gray-500 mt-1 text-center"></p>
                    <div class="flex flex-col sm:flex-row gap-2 mt-2">
                        <button id="testCustomSoundBtn" class="flex-1 counter-button bg-purple-500 hover:bg-purple-600 text-white"><i class="fas fa-play mr-2"></i> Test Sound</button>
                        <button id="stopCustomSoundBtn" class="flex-1 counter-button bg-red-500 hover:bg-red-600 text-white" disabled><i class="fas fa-stop mr-2"></i> Stop Sound</button>
                    </div>
                    <button id="clearCustomSoundBtn" class="mt-2 w-full counter-button bg-gray-500 hover:bg-gray-600 text-white text-sm"><i class="fas fa-times mr-2"></i> Clear Custom Sound</button>
                    <p class="text-xs text-red-500 mt-1">Max 2MB per audio file. Large files may affect performance and storage.</p>
                </div>


                <div>
                    <label for="stepInput" class="block text-sm font-medium text-gray-700">Increment/Decrement Step:</label>
                    <input type="number" id="stepInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" value="1" min="1">
                </div>
                <div>
                    <label for="minLimitInput" class="block text-sm font-medium text-gray-700">Minimum Value:</label>
                    <input type="number" id="minLimitInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" placeholder="e.g., 0" value="0">
                </div>
                <div>
                    <label for="limitSelect" class="block text-sm font-medium text-gray-700">Predefined Max Limit:</label>
                    <select id="limitSelect" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                        <option value="">No Limit</option>
                        <option value="10">10</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                        <option value="500">500</option>
                        <option value="1000">1000</option>
                    </select>
                </div>
                <div class="col-span-full">
                    <label for="customLimitInput" class="block text-sm font-medium text-gray-700">Custom Max Limit:</label>
                    <input type="number" id="customLimitInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" placeholder="Enter custom limit" min="0">
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Confirmation Modal HTML -->
    <div id="confirmationModal" class="flex items-center justify-center">
        <div class="modal-content">
            <p>Are you sure you want to delete this counter? This action cannot be undone.</p>
            <div class="modal-buttons">
                <button id="confirmDeleteBtn" class="modal-button confirm">Yes, Delete</button>
                <button id="cancelDeleteBtn" class="modal-button cancel">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // DOM element references
        const currentCounterName = document.getElementById('currentCounterName');
        const counterDisplay = document.getElementById('counterDisplay');
        const incrementBtn = document.getElementById('incrementBtn');
        const decrementBtn = document.getElementById('decrementBtn');
        const resetBtn = document.getElementById('resetBtn');
        const stepInput = document.getElementById('stepInput');
        const limitSelect = document.getElementById('limitSelect');
        const customLimitInput = document.getElementById('customLimitInput');
        const minLimitInput = document.getElementById('minLimitInput');
        const newCounterNameInput = document.getElementById('newCounterNameInput');
        const addCounterBtn = document.getElementById('addCounterBtn');
        const counterListDiv = document.getElementById('counterList');
        const zikrModeToggle = document.getElementById('zikrModeToggle');
        const zikrTargetInput = document.getElementById('zikrTargetInput');
        const zikrTargetContainer = document.getElementById('zikrTargetContainer');
        const soundEnabledToggle = document.getElementById('soundEnabledToggle');
        const customSoundFileInput = document.getElementById('customSoundFileInput');
        const testCustomSoundBtn = document.getElementById('testCustomSoundBtn');
        const stopCustomSoundBtn = document.getElementById('stopCustomSoundBtn');
        const clearCustomSoundBtn = document.getElementById('clearCustomSoundBtn');
        const customSoundFileNameDisplay = document.getElementById('customSoundFileNameDisplay');
        const customSoundOptions = document.getElementById('customSoundOptions');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBarFill = document.getElementById('progressBarFill');
        const splashScreen = document.getElementById('splash-screen');
        const mainAppContainer = document.querySelector('.main-app-container');

        // Page elements
        const countersListPage = document.getElementById('countersListPage');
        const singleCounterPage = document.getElementById('singleCounterPage');
        const backToCountersBtn = document.getElementById('backToCountersBtn');

        // Confirmation Modal elements
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
        let currentDeleteId = null; // To store the ID of the counter to be deleted

        // Global state variables
        let counters = [];
        let activeCounterId = null;
        let currentPlayingAudio = null;

        const synth = new Tone.Synth().toDestination();
        const MAX_FILE_SIZE_BYTES = 2 * 1024 * 1024; // 2MB for custom audio files

        /**
         * Switches the displayed page.
         * @param {string} pageId - The ID of the page to show ('countersListPage' or 'singleCounterPage').
         */
        function showPage(pageId) {
            if (pageId === 'countersListPage') {
                countersListPage.style.display = 'flex';
                singleCounterPage.style.display = 'none';
                stopSound(); // Stop any sound if returning to list page
            } else {
                countersListPage.style.display = 'none';
                singleCounterPage.style.display = 'flex';
            }
        }

        /**
         * Generates a unique ID for new counters.
         * @returns {string} A unique ID string.
         */
        function generateUniqueId() {
            return 'counter_' + Date.now() + Math.random().toString(36).substr(2, 9);
        }

        /**
         * Displays a temporary message box.
         * @param {string} message - The message to display.
         * @param {string} type - 'success' or 'error' (for styling).
         */
        function showMessageBox(message, type = 'error') {
            let messageDiv = document.querySelector('.message-box');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.classList.add('message-box');
                document.body.appendChild(messageDiv);
            }

            messageDiv.textContent = message;
            messageDiv.classList.remove('bg-green-500', 'bg-red-500');
            if (type === 'success') {
                messageDiv.classList.add('bg-green-500');
            } else {
                messageDiv.classList.add('bg-red-500');
            }

            messageDiv.classList.add('show');

            setTimeout(() => {
                messageDiv.classList.remove('show');
            }, 2000);
        }

        /**
         * Stops any currently playing custom audio.
         */
        function stopSound() {
            if (currentPlayingAudio) {
                currentPlayingAudio.pause();
                currentPlayingAudio.currentTime = 0;
                currentPlayingAudio = null;
            }
            // Ensure the stop button is disabled when no sound is playing
            if (stopCustomSoundBtn) { // Check if element exists before accessing
                stopCustomSoundBtn.disabled = true;
            }
        }

        /**
         * Plays a sound notification.
         * @param {boolean} [forceCustom=false] - If true, forces playing custom sound for testing.
         */
        function playSound(forceCustom = false) {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter || (!activeCounter.soundEnabled && !forceCustom)) {
                return;
            }

            stopSound();

            if (activeCounter.customSoundBase64 && (activeCounter.soundEnabled || forceCustom)) {
                try {
                    const audio = new Audio(activeCounter.customSoundBase64);
                    audio.play().then(() => {
                        currentPlayingAudio = audio;
                        if (stopCustomSoundBtn) {
                            stopCustomSoundBtn.disabled = false;
                        }
                    }).catch(e => {
                        console.error("Error playing custom audio:", e);
                        showMessageBox("Error playing custom sound. Try re-uploading.");
                        if (stopCustomSoundBtn) {
                            stopCustomSoundBtn.disabled = true;
                        }
                    });
                    audio.onended = () => {
                        if (stopCustomSoundBtn) {
                            stopCustomSoundBtn.disabled = true;
                        }
                        currentPlayingAudio = null;
                    };
                } catch (e) {
                    console.error("Invalid custom audio data:", e);
                    showMessageBox("Error playing custom sound. Try re-uploading.");
                }
            } else if (activeCounter.soundEnabled || forceCustom) {
                synth.triggerAttackRelease("C4", "8n");
                if (stopCustomSoundBtn) {
                    stopCustomSoundBtn.disabled = true;
                }
            }
        }

        /**
         * Saves the current state of counters to localStorage.
         */
        function saveCounters() {
            localStorage.setItem('superCounterAppCounters', JSON.stringify(counters));
            localStorage.setItem('superCounterAppActiveCounterId', activeCounterId);
        }

        /**
         * Loads counters and activeCounterId from localStorage.
         */
        function loadCounters() {
            const storedCounters = localStorage.getItem('superCounterAppCounters');
            const storedActiveCounterId = localStorage.getItem('superCounterAppActiveCounterId');

            if (storedCounters) {
                counters = JSON.parse(storedCounters);
                counters.forEach(c => {
                    if (c.isZikrMode === undefined) c.isZikrMode = false;
                    if (c.zikrTarget === undefined) c.zikrTarget = 0;
                    if (c.soundEnabled === undefined) c.soundEnabled = false;
                    if (c.customSoundBase64 === undefined) c.customSoundBase64 = null;
                    if (c.customSoundFileName === undefined) c.customSoundFileName = '';
                    if (c.minLimit === undefined) c.minLimit = 0;
                });
            } else {
                // No default counter on load anymore, user creates them.
                counters = [];
            }

            // Initially, no counter is active on the list page.
            // activeCounterId will be set when a counter is selected or added.
            activeCounterId = null;

            renderCounterList();
            // Do NOT call updateMainDisplay() directly here, as it's for singleCounterPage
            // We want to show the list page first.
            showPage('countersListPage');
        }

        /**
         * Gets the effective maximum limit for the active counter, prioritizing custom limit.
         * @returns {number|null} The limit value or null if no limit.
         */
        function getEffectiveMaxLimit() {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return null;

            const customValue = customLimitInput.value.trim();
            if (customValue !== '' && !isNaN(parseInt(customValue))) {
                return parseInt(customValue);
            }

            return limitSelect.value ? parseInt(limitSelect.value) : null;
        }

        /**
         * Updates the progress bar display.
         * @param {number} currentValue - The current value of the counter.
         * @param {number} min - The minimum value for the progress bar calculation.
         * @param {number} max - The maximum value for the progress bar calculation.
         */
        function updateProgressBar(currentValue, min, max) {
            if (min >= max) {
                progressBarContainer.style.display = 'none';
                return;
            }
            const percentage = ((currentValue - min) / (max - min)) * 100;
            progressBarFill.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
            progressBarContainer.style.display = 'block';
        }


        /**
         * Updates the main counter display and settings based on the active counter.
         * This function is specifically for the singleCounterPage.
         */
        function updateMainDisplay() {
            const activeCounter = counters.find(c => c.id === activeCounterId);

            if (activeCounter) {
                currentCounterName.textContent = activeCounter.isZikrMode ? `Zikr: ${activeCounter.name}` : activeCounter.name;
                counterDisplay.textContent = activeCounter.value;

                zikrModeToggle.checked = activeCounter.isZikrMode;
                zikrTargetInput.value = activeCounter.zikrTarget;
                zikrTargetContainer.style.display = activeCounter.isZikrMode ? 'block' : 'none';

                soundEnabledToggle.checked = activeCounter.soundEnabled;
                customSoundOptions.style.display = activeCounter.soundEnabled ? 'block' : 'none';

                const disableNormalSettings = activeCounter.isZikrMode;
                stepInput.disabled = disableNormalSettings;
                minLimitInput.disabled = disableNormalSettings;
                limitSelect.disabled = disableNormalSettings;
                customLimitInput.disabled = disableNormalSettings;

                if (!disableNormalSettings) {
                    stepInput.value = activeCounter.step;
                    minLimitInput.value = activeCounter.minLimit;

                    const predefinedLimit = limitSelect.querySelector(`option[value="${activeCounter.limit}"]`);
                    if (predefinedLimit) {
                        limitSelect.value = activeCounter.limit;
                        customLimitInput.value = '';
                    } else {
                        limitSelect.value = '';
                        customLimitInput.value = activeCounter.limit !== null ? activeCounter.limit : '';
                    }

                    const maxLimit = getEffectiveMaxLimit();
                    if (maxLimit !== null && maxLimit > activeCounter.minLimit) {
                        updateProgressBar(activeCounter.value, activeCounter.minLimit, maxLimit);
                    } else {
                        progressBarContainer.style.display = 'none';
                    }

                } else {
                    stepInput.value = 1;
                    minLimitInput.value = 0;
                    limitSelect.value = '';
                    customLimitInput.value = '';
                    progressBarContainer.style.display = 'none';
                }

                customSoundFileNameDisplay.textContent = activeCounter.customSoundFileName || 'No file selected';
                clearCustomSoundBtn.disabled = !activeCounter.customSoundBase64;
                testCustomSoundBtn.disabled = !activeCounter.customSoundBase64;
                stopCustomSoundBtn.disabled = (currentPlayingAudio === null);

                incrementBtn.disabled = false;
                decrementBtn.disabled = false;
                resetBtn.disabled = false;
                zikrModeToggle.disabled = false;
                zikrTargetInput.disabled = false; // Ensure zikr target input is enabled when zikr mode is on
                soundEnabledToggle.disabled = false;
                customSoundFileInput.disabled = !activeCounter.soundEnabled;
                testCustomSoundBtn.disabled = !activeCounter.customSoundBase64; // Re-enable if sound is present
                clearCustomSoundBtn.disabled = !activeCounter.customSoundBase64; // Re-enable if sound is present
            } else {
                currentCounterName.textContent = "No Counter Selected";
                counterDisplay.textContent = "---";
                stepInput.value = 1;
                minLimitInput.value = 0;
                limitSelect.value = '';
                customLimitInput.value = '';
                zikrModeToggle.checked = false;
                zikrTargetInput.value = '';
                zikrTargetContainer.style.display = 'none';
                soundEnabledToggle.checked = false;
                customSoundOptions.style.display = 'none';
                progressBarContainer.style.display = 'none';

                incrementBtn.disabled = true;
                decrementBtn.disabled = true;
                resetBtn.disabled = true;
                stepInput.disabled = true;
                minLimitInput.disabled = true;
                limitSelect.disabled = true;
                customLimitInput.disabled = true;
                zikrModeToggle.disabled = true;
                zikrTargetInput.disabled = true;
                soundEnabledToggle.disabled = true;
                customSoundFileInput.disabled = true;
                testCustomSoundBtn.disabled = true;
                stopCustomSoundBtn.disabled = true;
                clearCustomSoundBtn.disabled = true;
                customSoundFileNameDisplay.textContent = 'No file selected';
            }
        }

        /**
         * Renders the list of all available counters.
         */
        function renderCounterList() {
            counterListDiv.innerHTML = '';
            let counterNum = 1; // For default names
            counters.forEach(counter => {
                const listItem = document.createElement('li');
                listItem.id = `list-item-${counter.id}`;
                listItem.classList.add('counter-list-item');
                // No 'active' class here as active means on another page
                listItem.innerHTML = `
                    <span>${counter.name || `New Counter ${counterNum++}`} (${counter.value})</span>
                    <button class="delete-counter-btn" data-id="${counter.id}" title="Delete Counter">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                listItem.addEventListener('click', (event) => {
                    // Only select if not clicking the delete button
                    if (!event.target.closest('.delete-counter-btn')) {
                        selectCounter(counter.id);
                        showPage('singleCounterPage'); // Navigate to single counter page
                    }
                });
                counterListDiv.appendChild(listItem);
            });
            saveCounters();
        }

        /**
         * Selects a counter to make it active and prepares its display.
         * @param {string} id - The ID of the counter to select.
         */
        function selectCounter(id) {
            activeCounterId = id;
            updateMainDisplay(); // Update display with selected counter's data
            renderCounterList(); // Re-render list to reflect selection (though not visually "active" on list page)
            saveCounters();
        }

        /**
         * Adds a new counter to the list.
         * @param {string} name - The name of the new counter.
         */
        function addCounter(name) {
            let counterName = name.trim();
            if (!counterName) {
                // Generate a default name if none provided
                let nextCounterNum = 1;
                while (counters.some(c => c.name === `New Counter ${nextCounterNum}`)) {
                    nextCounterNum++;
                }
                counterName = `New Counter ${nextCounterNum}`;
            }

            const newCounter = {
                id: generateUniqueId(),
                name: counterName,
                value: 0,
                step: 1,
                limit: null,
                isZikrMode: false,
                zikrTarget: 0,
                soundEnabled: false,
                customSoundBase64: null,
                customSoundFileName: '',
                minLimit: 0,
            };
            counters.push(newCounter);
            newCounterNameInput.value = '';
            selectCounter(newCounter.id); // Select and display the new counter
            showPage('singleCounterPage'); // Immediately go to the new counter's page
            showMessageBox(`'${newCounter.name}' created!`, 'success');
        }

        /**
         * Initiates the deletion process by showing the confirmation modal.
         * @param {string} id - The ID of the counter to delete.
         */
        function showDeleteConfirmation(id) {
            currentDeleteId = id; // Store the ID globally
            confirmationModal.classList.add('show');
        }

        /**
         * Executes the deletion of a counter.
         * @param {string} id - The ID of the counter to delete.
         */
        function executeDelete(id) {
            if (activeCounterId === id) {
                stopSound();
            }

            counters = counters.filter(c => c.id !== id);
            if (activeCounterId === id) {
                activeCounterId = null; // Clear active counter
                showPage('countersListPage'); // Go back to the list
            }
            renderCounterList();
            showMessageBox('Counter deleted!', 'success');
            hideDeleteConfirmation(); // Hide the modal after deletion
        }

        /**
         * Hides the confirmation modal.
         */
        function hideDeleteConfirmation() {
            confirmationModal.classList.remove('show');
            currentDeleteId = null; // Clear the stored ID
        }

        // --- Event Listeners ---

        incrementBtn.addEventListener('click', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return;

            const step = parseInt(stepInput.value);
            const effectiveMaxLimit = getEffectiveMaxLimit();

            if (isNaN(step) || step < 1) {
                showMessageBox("Step value must be a positive number.");
                return;
            }

            if (activeCounter.isZikrMode) {
                if (activeCounter.value - step >= 0) {
                    activeCounter.value -= step;
                    if (activeCounter.value <= 0) {
                        activeCounter.value = 0;
                        showMessageBox("Zikr complete!", 'success');
                        playSound();
                    }
                } else {
                    activeCounter.value = 0;
                    showMessageBox("Zikr complete!", 'success');
                    playSound();
                }
            } else {
                if (effectiveMaxLimit === null || activeCounter.value + step <= effectiveMaxLimit) {
                    activeCounter.value += step;
                    if (effectiveMaxLimit !== null && activeCounter.value >= effectiveMaxLimit) {
                         showMessageBox(`Max limit of ${effectiveMaxLimit} reached!`, 'success');
                         playSound();
                    }
                } else {
                    showMessageBox(`Cannot increment beyond the limit of ${effectiveMaxLimit}!`);
                    playSound();
                }
            }
            activeCounter.step = step;
            activeCounter.limit = activeCounter.isZikrMode ? null : effectiveMaxLimit;
            updateMainDisplay();
            saveCounters();
        });

        decrementBtn.addEventListener('click', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return;

            const step = parseInt(stepInput.value);
            if (isNaN(step) || step < 1) {
                showMessageBox("Step value must be a positive number.");
                return;
            }

            if (activeCounter.isZikrMode) {
                if (activeCounter.value + step <= activeCounter.zikrTarget) {
                    activeCounter.value += step;
                } else {
                    activeCounter.value = activeCounter.zikrTarget;
                }
            } else {
                if (activeCounter.value - step >= activeCounter.minLimit) {
                    activeCounter.value -= step;
                    if (activeCounter.value <= activeCounter.minLimit) {
                        showMessageBox(`Min limit of ${activeCounter.minLimit} reached!`, 'error');
                    }
                } else {
                    activeCounter.value = activeCounter.minLimit;
                    showMessageBox(`Cannot decrement below the limit of ${activeCounter.minLimit}!`, 'error');
                }
            }
            activeCounter.step = step;
            activeCounter.limit = activeCounter.isZikrMode ? null : getEffectiveMaxLimit();
            updateMainDisplay();
            saveCounters();
        });

        resetBtn.addEventListener('click', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return;

            stopSound();

            if (activeCounter.isZikrMode) {
                activeCounter.value = activeCounter.zikrTarget;
                showMessageBox(`'${activeCounter.name}' Zikr reset to ${activeCounter.zikrTarget}.`, 'success');
            } else {
                activeCounter.value = activeCounter.minLimit;
                showMessageBox(`'${activeCounter.name}' reset to ${activeCounter.minLimit}.`, 'success');
            }
            updateMainDisplay();
            saveCounters();
        });

        addCounterBtn.addEventListener('click', () => {
            addCounter(newCounterNameInput.value);
        });

        newCounterNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addCounter(newCounterNameInput.value);
            }
        });

        counterListDiv.addEventListener('click', (event) => {
            const deleteButton = event.target.closest('.delete-counter-btn');
            if (deleteButton) {
                event.stopPropagation(); // Prevent the click from bubbling up to the listItem
                const idToDelete = deleteButton.dataset.id;
                showDeleteConfirmation(idToDelete); // Show custom confirmation modal
            }
            // The click on the list item itself is handled by the `listItem.addEventListener` in `renderCounterList`
            // and calls `selectCounter` and `showPage('singleCounterPage')`.
        });

        // Event listeners for the custom confirmation modal buttons
        confirmDeleteBtn.addEventListener('click', () => {
            if (currentDeleteId) {
                executeDelete(currentDeleteId);
            }
        });

        cancelDeleteBtn.addEventListener('click', () => {
            hideDeleteConfirmation();
        });

        backToCountersBtn.addEventListener('click', () => {
            showPage('countersListPage');
        });

        zikrModeToggle.addEventListener('change', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return;

            activeCounter.isZikrMode = zikrModeToggle.checked;
            if (activeCounter.isZikrMode) {
                const target = parseInt(zikrTargetInput.value);
                if (!isNaN(target) && target >= 0) {
                    activeCounter.zikrTarget = target;
                    activeCounter.value = target;
                } else {
                    activeCounter.zikrTarget = 0;
                    activeCounter.value = 0;
                    zikrTargetInput.value = 0;
                }
            } else {
                activeCounter.value = activeCounter.minLimit;
            }
            updateMainDisplay();
            saveCounters();
        });

        zikrTargetInput.addEventListener('input', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return;

            const target = parseInt(zikrTargetInput.value);
            if (!isNaN(target) && target >= 0) {
                activeCounter.zikrTarget = target;
            } else {
                activeCounter.zikrTarget = 0;
            }
            if (activeCounter.isZikrMode) {
                activeCounter.value = activeCounter.zikrTarget;
            }
            updateMainDisplay();
            saveCounters();
        });

        soundEnabledToggle.addEventListener('change', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (activeCounter) {
                activeCounter.soundEnabled = soundEnabledToggle.checked;
                updateMainDisplay();
                saveCounters();
            }
        });

        customSoundFileInput.addEventListener('change', (event) => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (!activeCounter) return;

            const file = event.target.files[0];
            if (file) {
                if (file.size > MAX_FILE_SIZE_BYTES) {
                    showMessageBox(`File size exceeds 2MB limit. Please choose a smaller file. Current: ${Math.round(file.size / (1024 * 1024))}MB`, 'error');
                    customSoundFileInput.value = '';
                    activeCounter.customSoundBase64 = null;
                    activeCounter.customSoundFileName = '';
                    updateMainDisplay();
                    saveCounters();
                    return;
                }

                const reader = new FileReader();
                reader.onloadend = () => {
                    activeCounter.customSoundBase64 = reader.result;
                    activeCounter.customSoundFileName = file.name;
                    updateMainDisplay();
                    saveCounters();
                    showMessageBox('Custom sound uploaded!', 'success');
                };
                reader.onerror = (error) => {
                    console.error("Error reading file:", error);
                    showMessageBox('Error uploading sound file.', 'error');
                    activeCounter.customSoundBase64 = null;
                    activeCounter.customSoundFileName = '';
                    updateMainDisplay();
                    saveCounters();
                };
                reader.readAsDataURL(file);
            } else {
                activeCounter.customSoundBase64 = null;
                activeCounter.customSoundFileName = '';
                updateMainDisplay();
                saveCounters();
            }
        });

        testCustomSoundBtn.addEventListener('click', () => {
            playSound(true);
        });

        stopCustomSoundBtn.addEventListener('click', () => {
            stopSound();
        });

        clearCustomSoundBtn.addEventListener('click', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (activeCounter) {
                stopSound();
                activeCounter.customSoundBase64 = null;
                activeCounter.customSoundFileName = '';
                customSoundFileInput.value = '';
                updateMainDisplay();
                saveCounters();
                showMessageBox('Custom sound cleared.', 'success');
            }
        });

        stepInput.addEventListener('change', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (activeCounter && !activeCounter.isZikrMode) {
                activeCounter.step = parseInt(stepInput.value);
                updateMainDisplay();
                saveCounters();
            }
        });

        minLimitInput.addEventListener('change', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (activeCounter && !activeCounter.isZikrMode) {
                const newMinLimit = parseInt(minLimitInput.value);
                if (!isNaN(newMinLimit)) {
                    activeCounter.minLimit = newMinLimit;
                    if (activeCounter.value < activeCounter.minLimit) {
                        activeCounter.value = activeCounter.minLimit;
                    }
                    updateMainDisplay();
                    saveCounters();
                } else {
                    showMessageBox("Minimum limit must be a number.");
                }
            }
        });

        limitSelect.addEventListener('change', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (activeCounter && !activeCounter.isZikrMode) {
                activeCounter.limit = limitSelect.value ? parseInt(limitSelect.value) : null;
                customLimitInput.value = '';
                updateMainDisplay();
                saveCounters();
            }
        });

        customLimitInput.addEventListener('input', () => {
            const activeCounter = counters.find(c => c.id === activeCounterId);
            if (activeCounter && !activeCounter.isZikrMode) {
                const customValue = customLimitInput.value.trim();
                if (customValue !== '' && !isNaN(parseInt(customValue))) {
                    activeCounter.limit = parseInt(customValue);
                    limitSelect.value = '';
                } else {
                    activeCounter.limit = null;
                }
                updateMainDisplay();
                saveCounters();
            }
        });

        // Initial app load logic including splash screen
        document.addEventListener('DOMContentLoaded', () => {
            mainAppContainer.style.display = 'none'; // Ensure main app is hidden initially

            setTimeout(() => {
                splashScreen.classList.add('fade-out');
                splashScreen.addEventListener('transitionend', () => {
                    splashScreen.style.display = 'none';
                    mainAppContainer.style.display = 'flex'; // Show the main app container
                    loadCounters(); // Load counters only after main app is visible
                }, { once: true });
            }, 2000);
        });
    </script>
</body>
</html>
